import tkinter as tk
from tkinter import ttk, messagebox
import random
import time
from datetime import datetime


class TestApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Тестирующая система - Цифровые системы и ПЛИС")
        self.root.geometry("1400x900")

        # Центрирование окна
        self.center_window()

        # Корпоративная цветовая палитра
        self.colors = {
            'bg': '#f8f9fa',
            'card_bg': '#ffffff',
            'header_bg': '#0d47a1',  # Глубокий синий
            'header_fg': '#ffffff',
            'sidebar_bg': '#1a237e',  # Темно-синий
            'sidebar_fg': '#e3f2fd',
            'primary': '#1565c0',  # Основной синий
            'primary_light': '#1976d2',
            'primary_dark': '#0d47a1',
            'secondary': '#546e7a',  # Серо-синий
            'success': '#2e7d32',  # Зеленый
            'success_light': '#4caf50',
            'warning': '#f57c00',  # Оранжевый
            'danger': '#c62828',  # Красный
            'text': '#263238',  # Темно-серый
            'text_light': '#607d8b',
            'border': '#e0e0e0',
            'hover': '#e3f2fd',
            'selected': '#bbdefb',
            'timer_ok': '#4caf50',
            'timer_warning': '#ff9800',
            'timer_critical': '#f44336',
            'progress_bg': '#e0e0e0',
            'progress_fg': '#1976d2'
        }

        # Теперь вызываем setup_styles (после инициализации colors)
        self.setup_styles()

        # Переменные
        self.all_questions = self.get_all_questions()
        self.selected_questions = []
        self.current_question_index = 0
        self.score = 0
        self.user_answers = []
        self.time_limit = 300  # 5 минут
        self.start_time = None
        self.timer_running = False
        self.answer_vars = {}
        self.user_name = ""
        self.user_group = ""
        self.test_mode = "экзамен"  # тренировка/экзамен

        # Статистика
        self.questions_answered = 0
        self.correct_answers = 0
        self.time_spent = []

        # Запускаем стартовый экран
        self.show_start_screen()

    def center_window(self):
        """Центрирование окна на экране"""
        self.root.update_idletasks()
        width = self.root.winfo_width()
        height = self.root.winfo_height()
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f'{width}x{height}+{x}+{y}')

    def setup_styles(self):
        """Настройка стилей для виджетов ttk"""
        style = ttk.Style()
        style.theme_use('clam')

        # Настройка основных стилей
        style.configure('Primary.TButton',
                        background=self.colors['primary'],
                        foreground='white',
                        borderwidth=0,
                        font=('Segoe UI', 11, 'bold'),
                        padding=(15, 10)
                        )
        style.map('Primary.TButton',
                  background=[('active', self.colors['primary_light']),
                              ('disabled', self.colors['border'])]
                  )

        style.configure('Secondary.TButton',
                        background=self.colors['secondary'],
                        foreground='white',
                        borderwidth=0,
                        font=('Segoe UI', 10),
                        padding=(12, 8)
                        )

        style.configure('Success.TButton',
                        background=self.colors['success'],
                        foreground='white',
                        borderwidth=0,
                        font=('Segoe UI', 11, 'bold'),
                        padding=(15, 10)
                        )

        style.configure('Danger.TButton',
                        background=self.colors['danger'],
                        foreground='white',
                        borderwidth=0,
                        font=('Segoe UI', 11),
                        padding=(12, 8)
                        )

        style.configure('Header.TLabel',
                        background=self.colors['header_bg'],
                        foreground='white',
                        font=('Segoe UI', 14, 'bold')
                        )

        style.configure('Card.TFrame',
                        background='white',
                        relief='solid',
                        borderwidth=1
                        )

        style.configure('Custom.Horizontal.TProgressbar',
                        thickness=20,
                        background=self.colors['progress_fg'],
                        troughcolor=self.colors['progress_bg']
                        )

        # Стиль для чекбоксов
        style.configure('TCheckbutton',
                        font=('Segoe UI', 10)
                        )

    def get_all_questions(self):
        """Возвращает полную базу из 81 вопроса"""
        return [
            {
                "question": "Каналы трассировки в строковых ПЛИС типа FPGA?",
                "options": {
                    "а": "состоят из металлических проводников",
                    "б": "соединяются программным способом",
                    "в": "могут быть соединены программно или аппаратно",
                    "г": "могут быть изменены в процессе функционирования",

                },
                "correct": ["а"],  # Несколько правильных ответов
                "points": 2  # Баллы за полностью правильный ответ
            },
            {
                "question": "К основным способам реализации алгоритмов цифровой обработки сигналов относятся способы?",
                "options": {
                    "а": "аппаратный",
                    "б": "программный",
                    "в": "транспарантный",
                    "г": "проекционный",
                    "д": "логический"
                },
                "correct": ["а", "б"],
                "points": 2
            },
            {
                "question": "Разработка цифровых систем на  программируемых логических интегральных схемах соответствует … способу реализации",
                "options": {
                    "а": "аппаратному",
                    "б": "программному",
                    "в": "транспарантному",
                    "г": "проекционному",
                    "д": "логическому"
                },
                "correct": ["а"],
                "points": 2
            },
            {
                "question": "Для повышения производительности ЦПОС могут быть использованы …",
                "options": {
                    "а": "повышение тактовой частоты работы процессора",
                    "б": "повышение напряжения питания ядра процессора",
                    "в": "понижение номинальной мощности потребления",
                    "г": "понижение тактовой частоты работы процессора",
                    "д": "увеличение количества арифметико-логических устройств в ядре процессора",
                },
                "correct": ["а", "д"],
                "points": 2
            },
            {
                "question": "Основной направленностью архитектуры VelosiTI в ЦПОС фирмы Texas Instruments является …",
                "options": {
                    "а": "повышение тактовой частоты работы процессора",
                    "б": "повышение напряжения питания ядра процессора",
                    "в": "понижение номинальной мощности потребления процессора",
                    "г": "понижение тактовой частоты работы процессора",
                    "д": "повышение производительности процессора",
                },
                "correct": ["д"],
                "points": 2
            },
            {
                "question": "К основным достоинствам ПЛИС относятся …",
                "options": {
                    "а": "короткий проектно-технологический цикл разработки цифрового устройства.",
                    "б": "возможность реконфигурации устройства",
                    "в": "отсутствие возможности реконфигурации устройства",
                    "г": "жесткая архитектура разработанного устройства",

                },
                "correct": ["а", "б"],
                "points": 2
            },
            {
                "question": "Недостатком программной реализации цифрового устройства по сравнению с аппаратной является …",
                "options": {
                    "а": "возможность изменения алгоритма работы разработанного устройства",
                    "б": "низкое быстродействие",
                    "в": "малое время изменения алгоритма работы устройства",
                    "г": "уменьшение времени отладки устройства",
                    "д": "невозможность изменения алгоритма работы разработанного устройства",
                },
                "correct": ["б"],
                "points": 2
            },
            {
                "question": "К достоинствам программной реализации цифрового устройства по сравнению с аппаратной относятся … ",
                "options": {
                    "а": "возможность изменения алгоритма работы разработанного устройства",
                    "б": "высокое быстродействие устройства",
                    "в": "малое время изменения алгоритма работы устройства",
                    "г": "уменьшение времени отладки устройства",
                },
                "correct": ["а", "в", "г"],
                "points": 2
            },
            {
                "question": "К достоинствам аппаратной реализации цифрового устройства по сравнению с программной относится …",
                "options": {
                    "а": "возможность изменения алгоритма работы разработанного устройства",
                    "б": "высокое быстродействие устройства",
                    "в": "малое время изменения алгоритма работы устройства",
                    "г": "уменьшение времени отладки устройства",
                },
                "correct": ["б"],
                "points": 2
            },
            {
                "question": "К недостаткам аппаратной реализации цифрового устройства по сравнению с программной относится … ",
                "options": {
                    "а": "отсутствие возможности изменения алгоритма работы разработанного устройства",
                    "б": "низкое быстродействие",
                    "в": "малое время изменения алгоритма работы устройства",
                    "г": "уменьшение времени отладки устройства",
                },
                "correct": ["а"],
                "points": 2
            },
            {
                "question": "К числу специфических особенностей цифровой обработки сигналов не относится …",
                "options": {
                    "а": "высокая скорость поступления исходных данных",
                    "б": "повторяемость многих операций в вычислительных алгоритмах",
                    "в": "необходимость обеспечения гибкости и перестройки цифровых систем",
                    "г": "необходимость увеличения алгоритмической задержки принимаемого сигнала при обработке цифрового сигнала",
                },
                "correct": ["г"],
                "points": 2
            },
            {
                "question": "Шина данных памяти данных в цифровых процессорах обработки сигналов предназначена для передачи …",
                "options": {
                    "а": "адресов ячеек памяти программ",
                    "б": "команд, хранящихся в памяти программ, а также данных при использовании памяти программ для хранения данных",
                    "в": "адресов ячеек памяти данных",
                    "г": "данных, хранящихся в памяти цифрового процессора обработки сигналов",
                },
                "correct": ["г"],
                "points": 2
            },
            {
                "question": "… не относится к числу требований, предъявляемых к цифровым процессорам обработки сигналов",
                "options": {
                    "а": "быстрое выполнение типовых операций ЦОС",
                    "б": "параллельное выполнение отдельных частей исполняемого алгоритма, достигаемое аппаратной реализацией ряда типовых алгоритмов ЦОС",
                    "в": "наличие значительной внутрикристальной памяти данных и памяти программ",
                    "г": "аппаратная реализация умножителя",
                    "д": "высокая производительность",
                    "е": "высокое напряжение питания",
                },
                "correct": ["е"],
                "points": 2
            },
            {
                "question": "К числу требований, предъявляемых к цифровым процессорам обработки сигналов, относятся …",
                "options": {
                    "а": "быстрое выполнение типовых операций ЦОС",
                    "б": "низкая потребляемая мощность",
                    "в": "наличие значительной внутрикристальной памяти данных и памяти программ",
                    "г": "аппаратная реализация умножителя",
                    "д": "высокая производительность",
                    "е": "высокое напряжение питания",
                    "ж": "низкая разрядность данных в АЛУ",
                },
                "correct": ["а", "б", "в", "г", "д"],
                "points": 2
            },
            {
                "question": "Основным отличительным признаком гарвардской архитектуры цифровых процессоры обработки сигналов является … ",
                "options": {
                    "а": "наличие аппаратно реализованного умножителя в формате слова",
                    "б": "наличие раздельных устройств и шин для хранения и передачи программ и данных",
                    "в": "наличие сопроцессора",
                    "г": "наличие значительной внутрикристальной памяти",
                },
                "correct": ["б"],
                "points": 2
            },
            {
                "question": "Шина адресов памяти программ в цифровых процессорах обработки сигналов предназначена для передачи …",
                "options": {
                    "а": "адресов ячеек памяти программ",
                    "б": "команд, хранящихся в памяти программ, а также данных при использовании памяти программ для хранения данных",
                    "в": "адресов ячеек памяти данных",
                    "г": "данных, хранящихся в памяти цифрового процессора обработки сигналов",
                },
                "correct": ["а"],
                "points": 2
            },
            {
                "question": "Шина данных памяти программ в цифровых процессорах обработки сигналов предназначена для передачи …",
                "options": {
                    "а": "адресов ячеек памяти программ",
                    "б": "команд, хранящихся в памяти программ, а также данных при использовании памяти программ для хранения данных",
                    "в": "адресов ячеек памяти данных",
                    "г": "данных, хранящихся в памяти цифрового процессора обработки сигналов ",
                },
                "correct": ["б"],
                "points": 2
            },
            {
                "question": "Шина адресов памяти данных в цифровых процессорах обработки сигналов предназначена для передачи … ",
                "options": {
                    "а": "адресов ячеек памяти программ",
                    "б": "команд, хранящихся в памяти программ, а также данных при использовании памяти программ для хранения данных",
                    "в": "адресов ячеек памяти данных",
                    "г": "данных, хранящихся в памяти цифрового процессора обработки сигналов",
                },
                "correct": ["в"],
                "points": 2
            },
            {
                "question": "Устройство управления выполнением программы в цифровых процессорах обработки сигналов …",
                "options": {
                    "а": "вырабатывает сигналы управления работой всех узлов процессора",
                    "б": "предназначено для хранения дополнительной информации памяти программ и данных",
                    "в": "управляет режимом доступа к регистрам ЦПОС в процессе отладки программы",
                    "г": "осуществляет обмен сигналами с внешними устройствами",
                },
                "correct": ["а"],
                "points": 2
            },
            {
                "question": "Внешние шины адресов и данных цифровых процессоров обработки сигналов предназначены для …",
                "options": {
                    "а": "поддержки режима хранения программ и данных во внешних запоминающих устройствах",
                    "б": "обращения к внешним периферийным устройствам, обеспечивающим функционирование ЦПОС",
                    "в": "управления тактовой частотой работы ЦПОС",
                    "г": "обращения к арифметико-логическому устройству ЦПОС",
                    "д": "считывания данных из памяти программ и данных ЦПОС",
                    "е": "обращения к дополнительным функциональным модулям ЦПОС"
                },
                "correct": ["а"],
                "points": 2,

            },
            {
                "question": "Устройства ввода/вывода данных в цифровом процессоре обработки сигналов …",
                "options": {
                    "а": "вырабатывает сигналы управления работой всех узлов процессора",
                    "б": "предназначены для хранения дополнительной информации памяти программ и данных",
                    "в": "управляет режимом доступа к регистрам ЦПОС в процессе отладки программы",
                    "г": "осуществляет обмен сигналами с внешними устройствами"
                },
                "correct": ["г"],
                "points": 2,
            },
            {

                "question": "Работа цифрового процессора обработки сигналов в режиме с прерываниями предназначена для …",
                "options": {
                    "а": "согласования работы процессора с внешними устройствами",
                    "б": "управления режимом адресации в процессоре",
                    "в": "обращения к дополнительным функциональным устройствам процессора",
                    "г": "управления тактовой частотой работы процессора"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Разрядность арифметико-логического устройства ЦПОС, как правило …",
                "options": {
                    "а": "меньше разрядности слова процессора",
                    "б": "больше разрядности слова процессора",
                    "в": "равна разрядности слова процессора",
                    "г": "гораздо меньше разрядности слова процессора"
                },
                "correct": ["б"],
                "points": 2,

            },
            {
                "question": "Устройство генерации адреса в цифровом процессоре обработки сигналов …",
                "options": {
                    "а": "формирует адреса данных, извлекаемых из памяти данных и памяти программ",
                    "б": "предназначено для хранения дополнительной информации об адресах памяти программ и данных",
                    "в": "управляет режимом доступа к регистрам ЦПОС в процессе отладки программы"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Слово, двойное слово и полуслово являются по отношению к цифровым процессорам обработки сигналов …",
                "options": {
                    "а": "формами представления чисел",
                    "б": "форматами представления чисел",
                    "в": "разновидностями кодов",
                    "г": "типами арифметики процессора"
                },
                "correct": ["б"],
                "points": 2,

            },
            {

                "question": "Единицами измерения … цифрового процессора обработки сигналов являются MIPS и MFLOPS.",
                "options": {
                    "а": "внутренней тактовой частоты",
                    "б": "производительности",
                    "в": "длительности командного цикла",
                    "г": "объема и разновидности внутренней памяти",
                    "д": "временнóй задержки"
                },
                "correct": ["б"],
                "points": 2,

            },
            {

                "question": "Принципиальное отличие цифровых процессоров обработки сигналов от универсальных процессоров заключается в …",
                "options": {
                    "а": "аппаратной реализации операционных узлов, ориентированных на выполнение распространенных операций цифровой обработки сигналов",
                    "б": "диапазоне тактовых частот",
                    "в": "возможности реализации режима категорированной многозадачности",
                    "г": "наличии арифметико-логического устройства"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "ЦПОС компании Texas Instruments на основе платформ … ориентированы на задачи цифровой обработки изображений.",
                "options": {
                    "а": "C'5ХХХ",
                    "б": "C'2ХХХ",
                    "в": "C'6ХХХ",
                    "г": "C'24ХХ",
                    "д": "DaVinci"
                },
                "correct": ["в", "д"],
                "points": 2,

            },
            {

                "question": "Внутрикристальный эмулятор цифрового процессора обработки сигналов предназначен для …",
                "options": {
                    "а": "выполнения логики отладки процессора",
                    "б": "обеспечения прямого доступа к памяти",
                    "в": "повышения производительности процессора при обработке данных в форме с плавающей точкой",
                    "г": "выполнения логических операций сравнения, выбора и хранения"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Цифровой процессор обработки сигналов TMS320VC5416 для представления чисел использует …",
                "options": {
                    "а": "форму с фиксированной точкой",
                    "б": "форму с плавающей точкой",
                    "в": "программный метод выбора формы представления числа",
                    "г": "аппаратный метод выбора формы представления числа"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Собственный шум цифрового процессора обработки сигналов, как правило, оценивается …",
                "options": {
                    "а": "в точке входа",
                    "б": "в точке выхода",
                    "в": "на выходе аппаратного умножителя",
                    "г": "на выходе арифметико-логического устройства"
                },
                "correct": ["б"],
                "points": 2,

            },
            {

                "question": "Используемый тип арифметики в цифровом процессоре обработки сигналов соответствует … представления чисел.",
                "options": {
                    "а": "форме",
                    "б": "формату",
                    "в": "коду",
                    "г": "разряду"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Используемая разрядность данных в цифровом процессоре обработки сигналов соответствует … представления чисел.",
                "options": {
                    "а": "форме",
                    "б": "формату",
                    "в": "коду",
                    "г": "системе команд"
                },
                "correct": ["б"],
                "points": 2,

            },
            {

                "question": "Число 567 является шестнадцатеричным эквивалентом двоичного числа …",
                "options": {
                    "а": "101101100111",
                    "б": "11011100001",
                    "в": "10101100111",
                    "г": "11100010111"
                },
                "correct": ["в"],
                "points": 2,

            },
            {

                "question": "Внутренняя тактовая частота цифрового процессора обработки сигналов напрямую связана с …",
                "options": {
                    "а": "производительностью процессора",
                    "б": "объемом внутренней памяти процессора",
                    "в": "разрядностью представления чисел",
                    "г": "напряжением питания ядра процессора",
                    "д": "форме представления чисел"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Производительность цифрового процессора обработки сигналов характеризует …",
                "options": {
                    "а": "скорость обработки данных в процессоре",
                    "б": "потребляемую мощность процессором в процессе функционирования",
                    "в": "объем доступного ОЗУ и ПЗУ в процессоре",
                    "г": "количество и разновидность дополнительных модулей ядра процессора",
                    "д": "величину собственных шумов квантования"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Способами увеличения производительности ЦПОС являются …",
                "options": {
                    "а": "увеличение количества функциональных модулей процессора (АЛУ, умножителей)",
                    "б": "увеличение количества дополнительных специализированных устройств и сопроцессоров",
                    "в": "увеличение разрядности шин передачи данных и программ для увеличения количества одновременно передаваемой информации",
                    "г": "увеличение времени командного цикла"
                },
                "correct": ["а", "б", "в"],
                "points": 2,

            },
            {

                "question": "Архитектура VLIW компании Texas Instruments предусматривает … нескольких простых команд, каждая из которых определяет единственную операцию.",
                "options": {
                    "а": "параллельное выполнение в независимых операционных модулях",
                    "б": "последовательное выполнение в независимых операционных модулях",
                    "в": "последовательное выполнение в одном операционном модуле",
                    "г": "параллельное выполнение в одном операционном модуле"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Оценка реальной производительности цифрового процессора обработки сигналов реализуется на группе эталонных задач ЦОС с оценкой …",
                "options": {
                    "а": "времени их выполнения",
                    "б": "затраченной мощности",
                    "в": "объема затраченного ресурса запоминающих устройств",
                    "г": "количество и разновидностей запрашиваемых прерываний"
                },
                "correct": ["а"],
                "points": 2,

            },
            {
                "question": "Кэш-памятью ЦПОС называется …",
                "options": {
                    "а": "буферная память между арифметико-логическим устройством и ОЗУ",
                    "б": "некоторый объем памяти, выделяемый программно из ОЗУ для реализации процедур прерываний",
                    "в": "отдел ПЗУ процессора, в котором хранится информация о режимах отладки ЦПОС",
                    "г": "память процессора, в которой постоянно находится информация о задействовании узлов ЦПОС в процессе функционирования"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Напряжение питания процессора является характеристикой ЦПОС, важной при выборе его для …",
                "options": {
                    "а": "разработки носимых систем ЦОС с батарейным питанием",
                    "б": "увеличения производительности системы ЦОС за счет использования архитектурных решений",
                    "в": "решения задач ЦОС в реальном масштабе времени",
                    "г": "реализации системы, требующей достаточно большой объем вычислений"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Цифровые процессоры фирмы Texas Instruments на платформе 'C5000' в основном применяются …",
                "options": {
                    "а": "в цифровых системах управления и контроля",
                    "б": "в ресурсоемких приложениях обработки голоса и данных типа сотовых телефонов, пейджеров, для систем передачи голоса по IP-сетям и в персональных информационных системах",
                    "в": "в модемных пулах, коммутаторах АТС, устройствах трехмерной графики, видео серверах, высокоскоростных устройствах растровой обработки изображений",
                    "г": "в персональных электронно-вычислительных машинах в качестве основного процессорного устройства"
                },
                "correct": ["б"],
                "points": 2,

            },
            {

                "question": "Цифровые процессоры фирмы Texas Instruments на платформе 'C6000' в основном применяются …",
                "options": {
                    "а": "в цифровых системах управления и контроля",
                    "б": "в ресурсоемких приложениях обработки голоса и данных типа сотовых телефонов, пейджеров, для систем передачи голоса по IP-сетям",
                    "в": "в модемных пулах, коммутаторах АТС, устройствах кодирования и распознавания речи, устройствах трехмерной графики, видео серверах, высокоскоростных устройствах растровой обработки изображений",
                    "г": "в персональных электронно-вычислительных машинах в качестве основного процессорного устройства"
                },
                "correct": ["в"],
                "points": 2,

            },
            {

                "question": "Тактовая частота процессора TMS320VC5416 равна … МГц.",
                "options": {
                    "а": "120",
                    "б": "140",
                    "в": "160",
                    "г": "180"
                },
                "correct": ["в"],
                "points": 2,

            },
            {

                "question": "Пиковая производительность процессора TMS320VC5416 равна … MIPS.",
                "options": {
                    "а": "120",
                    "б": "140",
                    "в": "160",
                    "г": "180"
                },
                "correct": ["в"],
                "points": 2,

            },
            {

                "question": "Длительность командного цикла процессора TMS320VC5416 равна …",
                "options": {
                    "а": "6,25 нс",
                    "б": "0,625 нс",
                    "в": "625 нс",
                    "г": "62,5 нс"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "В процессоре TMS320VC5416 данные представляются …",
                "options": {
                    "а": "в форме с фиксированной точкой в дополнительном коде",
                    "б": "в форме с плавающей точкой в дополнительном коде",
                    "в": "в форме с фиксированной точкой в обратном коде",
                    "г": "в форме с плавающей точкой в прямом коде"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "В процессоре TMS320VC5416 формат слова содержит … бит.",
                "options": {
                    "а": "8",
                    "б": "16",
                    "в": "24",
                    "г": "32"
                },
                "correct": ["б"],
                "points": 2,

            },
            {

                "question": "В процессоре TMS320VC5416 формат двойного слова содержит … бита.",
                "options": {
                    "а": "16",
                    "б": "24",
                    "в": "32",
                    "г": "40"
                },
                "correct": ["в"],
                "points": 2,

            },
            {

                "question": "В процессоре TMS320VC5416 формат расширенного слова содержит … бит.",
                "options": {
                    "а": "16",
                    "б": "24",
                    "в": "32",
                    "г": "40"
                },
                "correct": ["г"],
                "points": 2,

            },
            {

                "question": "В состав ядра процессора TMS320VC5416 входят …",
                "options": {
                    "а": "устройство сдвига",
                    "б": "блок расчета экспоненты",
                    "в": "блок сравнения, выбора и хранения",
                    "г": "тактный генератор с системой фазовой автоподстройки частоты",
                    "д": "умножитель в формате двойного слова",
                    "е": "аккумуляторы в формате расширенного слова"
                },
                "correct": ["а", "б", "в", "е"],
                "points": 2,

            },
            {

                "question": "Умножитель ядра процессора TMS320VC5416 выполняет процедуру умножения данных, представленных в формате …",
                "options": {
                    "а": "слова",
                    "б": "двойного слова",
                    "в": "расширенного слова",
                    "г": "полуслова",
                    "д": "байта"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Накопитель блока выполнения операции умножения с накоплением процессора TMS320VC5416 осуществляет представление данных в формате …",
                "options": {
                    "а": "слова",
                    "б": "двойного слова",
                    "в": "расширенного слова",
                    "г": "полуслова",
                    "д": "байта"
                },
                "correct": ["в"],
                "points": 2,

            },
            {

                "question": "Арифметико-логическое устройство процессора TMS320VC5416 осуществляет представление данных в формате …",
                "options": {
                    "а": "слова",
                    "б": "двойного слова",
                    "в": "расширенного слова",
                    "г": "полуслова",
                    "д": "байта"
                },
                "correct": ["в"],
                "points": 2,

            },
            {

                "question": "Арифметико-логическое устройство процессора TMS320VC5416 осуществляет процедуры …",
                "options": {
                    "а": "умножения",
                    "б": "сложения",
                    "в": "бит-манипуляций",
                    "г": "вычитания"
                },
                "correct": ["б", "в", "г"],
                "points": 2,

            },
            {

                "question": "Устройство сдвига в ядре ЦПОС TMS320VC5416 осуществляет представление данных в формате …",
                "options": {
                    "а": "слова",
                    "б": "двойного слова",
                    "в": "расширенного слова",
                    "г": "полуслова"
                },
                "correct": ["в"],
                "points": 2,

            },
            {

                "question": "Программируемый генератор задержек процессора TMS320VC5416 осуществляет …",
                "options": {
                    "а": "временное согласование процессора с разноскоростной внешней периферией, включая внешние элементы памяти",
                    "б": "предотвращение возможных конфликтов при обращении к различным типам внутренней и внешней памяти",
                    "в": "формирование временной шкалы прерываний и временных задержек",
                    "г": "формирование системы тактовых частот функционирования элементов процессора"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Таймер процессора TMS320VC5416 осуществляет …",
                "options": {
                    "а": "временное согласование процессора с разноскоростной внешней периферией, включая внешние элементы памяти",
                    "б": "предотвращение возможных конфликтов при обращении к различным типам внутренней и внешней памяти",
                    "в": "формирование временной шкалы прерываний и временных задержек",
                    "г": "формирование системы тактовых частот функционирования элементов процессора"
                },
                "correct": ["в"],
                "points": 2,
            },

            {

                "question": "Программируемый переключатель банков памяти процессора TMS320VC5416 осуществляет …",
                "options": {
                    "а": "временное согласование процессора с разноскоростной внешней периферией, включая внешние элементы памяти",
                    "б": "предотвращение возможных конфликтов при обращении к различным типам внутренней и внешней памяти",
                    "в": "формирование временной шкалы прерываний и временных задержек",
                    "г": "формирование системы тактовых частот функционирования элементов процессора"
                },
                "correct": ["б"],
                "points": 2,

            },
            {

                "question": "Тактовый генератор с системой фазовой автоподстройки частоты процессора TMS320VC5416 осуществляет …",
                "options": {
                    "а": "временное согласование процессора с разноскоростной внешней периферией, включая внешние элементы памяти",
                    "б": "предотвращение возможных конфликтов при обращении к различным типам внутренней и внешней памяти",
                    "в": "формирование временной шкалы прерываний и временных задержек",
                    "г": "формирование системы тактовых частот функционирования элементов процессора"
                },
                "correct": ["г"],
                "points": 2,

            },
            {

                "question": "Порт хост-интерфейса процессора TMS320VC5416 является …",
                "options": {
                    "а": "параллельным портом ввода/вывода, предназначенным для прямого обмена данными с другим процессором, использующим 8- или 16-битный формат представления данных",
                    "б": "последовательным портом ввода/вывода, предназначенным для прямого обмена данными с другим процессором, использующим 8- или 16-битный формат представления данных",
                    "в": "параллельным портом ввода/вывода, предназначенным для прямого обмена данными с другими периферийными устройствами, использующими только 16-битный формат представления данных",
                    "г": "последовательным портом ввода/вывода, предназначенным для прямого обмена данными с другими периферийными устройствами, использующими 8- или 16-битный формат представления данных"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "JTAG-эмулятор процессора TMS320VC5416 обеспечивает …",
                "options": {
                    "а": "быстрый и независимый доступ к внутренним регистрам, элементам памяти и периферии процессора, содержит логику его отладки",
                    "б": "формирование шкалы прерываний процессора при его функционировании",
                    "в": "независимый доступ к внутренним элементам памяти для формирования шкалы тактовых частот, используемых для синхронизации всех узлов процессора",
                    "г": "скоростной доступ к внешним запоминающим устройствам, содержит логику их отладки"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Система обеспечения экономного режима энергопотребления процессора TMS320VC5416 по команде IDLE1 осуществляет …",
                "options": {
                    "а": "отключение электропитания ядра процессора",
                    "б": "отключение электропитания ядра и периферийных устройств процессора",
                    "в": "полное отключение электропитания процессора",
                    "г": "отключение электропитания ядра процессора и банков памяти"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Система обеспечения экономного режима энергопотребления процессора TMS320VC5416 по команде IDLE2 осуществляет …",
                "options": {
                    "а": "отключение электропитания ядра процессора",
                    "б": "отключение электропитания ядра и периферийных устройств процессора",
                    "в": "полное отключение электропитания процессора",
                    "г": "отключение электропитания ядра процессора и банков памяти"
                },
                "correct": ["б"],
                "points": 2,

            },
            {

                "question": "Система обеспечения экономного режима энергопотребления процессора TMS320VC5416 по команде IDLE3 осуществляет …",
                "options": {
                    "а": "отключение электропитания ядра процессора",
                    "б": "отключение электропитания ядра и периферийных устройств процессора",
                    "в": "полное отключение электропитания процессора",
                    "г": "отключение ядра процессора и питания банков памяти"
                },
                "correct": ["в"],
                "points": 2,

            },
            {

                "question": "Многоканальные буферизированные последовательные порты McBSP0, McBSP1 и McBSP2 процессора TMS320VC5416 характеризуются следующими особенностями: ...",
                "options": {
                    "а": "являются высокоскоростными полнодуплексными шестиконтактными портами",
                    "б": "служат для непосредственного обмена данными между TMS320VC5416 и взаимодействующими процессорами",
                    "в": "служат для непосредственного обмена данными с внешней последовательной периферией",
                    "г": "служат для доступа к порту устройства генерации адресов ядра ЦПОС в процессе обмена данными между TMS320VC5416 и взаимодействующими процессорами"
                },
                "correct": ["а", "б", "в"],
                "points": 2,

            },
            {

                "question": "Программируемые логические интегральные схемы характеризуются следующими особенностями: …",
                "options": {
                    "а": "имеют жесткую архитектуру взаимодействия составных элементов",
                    "б": "являются средством аппаратной реализации систем ЦОС",
                    "в": "содержат несколько арифметико-логических устройств",
                    "г": "имеют гибкую архитектуру взаимодействия составных элементов"
                },
                "correct": ["б", "г"],
                "points": 2,

            },
            {

                "question": "В структуре PLA ПЛИС программируется …",
                "options": {
                    "а": "только матрица 'ИЛИ'",
                    "б": "только матрица 'И'",
                    "в": "и матрица 'И', и матрица 'ИЛИ'",
                    "г": "только матрица 'ИЛИ-НЕ'"
                },
                "correct": ["в"],
                "points": 2,

            },
            {

                "question": "В структуре PROM ПЛИС программируется …",
                "options": {
                    "а": "только матрица 'ИЛИ'",
                    "б": "только матрица 'И'",
                    "в": "и матрица 'И', и матрица 'ИЛИ'",
                    "г": "только матрица 'ИЛИ-НЕ'"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "В структуре PAL ПЛИС программируется …",
                "options": {
                    "а": "только матрица 'ИЛИ'",
                    "б": "только матрица 'И'",
                    "в": "и матрица 'И', и матрица 'ИЛИ'",
                    "г": "только матрица 'ИЛИ-НЕ'"
                },
                "correct": ["б"],
                "points": 2,

            },
            {

                "question": "В структуре PROM ПЛИС матрица 'И' всегда …",
                "options": {
                    "а": "настроена на функции дешифратора",
                    "б": "программируется",
                    "в": "настроена на функции компаратора",
                    "г": "настроена на функции мультивибратора"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "В структуре PROM ПЛИС матрица 'ИЛИ' всегда …",
                "options": {
                    "а": "настроена на функции дешифратора",
                    "б": "программируется",
                    "в": "настроена на функции компаратора",
                    "г": "настроена на функции мультивибратора"
                },
                "correct": ["б"],
                "points": 2,

            },
            {

                "question": "В структуре PAL ПЛИС матрица 'ИЛИ' всегда …",
                "options": {
                    "а": "настроена на функции дешифратора",
                    "б": "программируется",
                    "в": "настроена на функции компаратора",
                    "г": "имеет фиксированную настройку"
                },
                "correct": ["г"],
                "points": 2,

            },
            {

                "question": "ПЛИС типа CPLD представляют собой совокупность функциональных блоков с архитектурой …, объединенных программируемой матрицей переключений.",
                "options": {
                    "а": "PAL",
                    "б": "PROM",
                    "в": "PLA",
                    "г": "FPGA"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "ПЛИС типа FPGA классифицируются на …",
                "options": {
                    "а": "матричные и строковые",
                    "б": "строковые и многомерные",
                    "в": "матричные и трассировочные",
                    "г": "строковые и трассировочные"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "В строковых ПЛИС типа FPGA логические элементы расположены в виде строк, … расположены каналы трассировки.",
                "options": {
                    "а": "между которыми",
                    "б": "вертикально к которым",
                    "в": "внутри которых",
                    "г": "по периметру которых"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Вертикальные проводники в строковых ПЛИС типа FPGA подсоединяются к линиям горизонтальных каналов с помощью …",
                "options": {
                    "а": "программируемых перемычек",
                    "б": "металлических проводников",
                    "в": "жестко закрепленных перемычек",
                    "г": "элементов матричной логики"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "В матричных ПЛИС типа FPGA логические элементы организованы в виде матрицы, а между …",
                "options": {
                    "а": "строками и столбцами расположены каналы трассировки, по краям расположены блоки ввода/вывода данных",
                    "б": "столбцами расположены каналы трассировки, на которых расположены блоки ввода/вывода данных",
                    "в": "строками расположены каналы трассировки, на которых расположены блоки ввода/вывода данных",
                    "г": "строками и столбцами расположены каналы трассировки, на которых расположены блоки ввода/вывода данных"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Реализация межсоединений в ПЛИС типа CPLD осуществляется …",
                "options": {
                    "а": "с помощью матрицы переключений или каналов трассировки",
                    "б": "с помощью стоковых или столбцовых трассировок",
                    "в": "с помощью программируемых матриц PLA или PAL",
                    "г": "с помощью программируемых матриц FLEX или PAL"
                },
                "correct": ["а"],
                "points": 2,

            },
            {

                "question": "Реальный масштаб времени предполагает, что …",
                "options": {
                    "а": "время вычисления не превышает период дискретизации (в случае обособленной обработки каждого отсчета исходного сигнала) или длительности сегмента исходного сигнала (в случае блочной обработки), при этом расчет текущего значения выходного сигнала системы опережает по времени поступление следующего отсчета (сегмента)",
                    "б": "время вычисления превышает период дискретизации (в случае обработки каждого отсчета исходного сигнала) или длительность сегмента исходного сигнала (в случае блочной обработки), при этом расчет текущего значения выходного сигнала системы опережает по времени поступление следующего отсчета (сегмента)",
                    "в": "время вычисления не превышает период дискретизации при обработке каждого отсчета сигнала или длительность сегмента исходного сигнала, при этом расчет текущего значения выходного сигнала системы не опережает по времени поступление следующего отсчета (сегмента)",
                    "г": "время вычисления превышает период дискретизации при обработке каждого отсчета сигнала или длительность сегмента исходного сигнала, при этом расчет текущего значения выходного сигнала системы не опережает по времени поступление следующего отсчета (сегмента)"
                },
                "correct": ["а"],
                "points": 2,

            },
            {
                "question": "… не относятся к средствам аппаратной реализации цифровых систем?",
                "options": {
                    "а": "цифровые процессоры обработки сигналов",
                    "б": "программируемые логические интегральные схемы",
                    "в": "микроконтроллеры",
                    "г": "программы с использованием языка ассемблера",
                    "д": "программы с использование различных языков высокого уровня",
                    "е": "совокупность цифровых функциональных блоков",
                },
                "correct": ["г", "д"],
                "points": 2
            },

        ]

    def show_start_screen(self):
        """Показывает профессиональный стартовый экран"""
        self.clear_window()

        # Основной контейнер
        main_container = tk.Frame(self.root, bg=self.colors['bg'])
        main_container.pack(fill=tk.BOTH, expand=True)

        # Верхняя панель с логотипом
        header = tk.Frame(main_container, bg=self.colors['header_bg'], height=70)
        header.pack(fill=tk.X)

        # Логотип и название
        logo_frame = tk.Frame(header, bg=self.colors['header_bg'])
        logo_frame.pack(side=tk.LEFT, padx=30, pady=15)

        tk.Label(logo_frame, text="📊", font=('Arial', 24),
                 bg=self.colors['header_bg'], fg='white').pack(side=tk.LEFT)

        tk.Label(logo_frame, text="Тестирования для курсантов",
                 font=('Segoe UI', 20, 'bold'),
                 bg=self.colors['header_bg'], fg='white').pack(side=tk.LEFT, padx=10)

        tk.Label(logo_frame, text="Цифровые системы и ПЛИС",
                 font=('Segoe UI', 12),
                 bg=self.colors['header_bg'], fg='#bbdefb').pack(side=tk.LEFT, padx=5)

        # Основное содержание
        content = tk.Frame(main_container, bg=self.colors['bg'])
        content.pack(fill=tk.BOTH, expand=True, padx=40, pady=40)

        # Левая панель - информация
        left_panel = tk.Frame(content, bg='white', relief='solid', bd=1)
        left_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 20))

        # Информация о системе
        info_frame = tk.Frame(left_panel, bg='white', padx=30, pady=30)
        info_frame.pack(fill=tk.BOTH, expand=True)

        tk.Label(info_frame, text="Добро пожаловать в систему тестирования",
                 font=('Segoe UI', 22, 'bold'),
                 bg='white', fg=self.colors['text']).pack(pady=(0, 10))

        tk.Label(info_frame, text="Кафедра электроники и теории электросвязи",
                 font=('Segoe UI', 12),
                 bg='white', fg=self.colors['text_light']).pack(pady=(0, 30))

        # Особенности системы
        features = [
            ("📊", "20 вопросов в экзамене"),
            ("📚", "Все вопросы в тренировке"),
            ("⏱️", "Ограничение времени: 10 минут (экзамен)"),
            ("🎯", "Адаптивная система оценки"),
            ("📈", "Детальная статистика")
        ]

        for icon, text in features:
            feature_frame = tk.Frame(info_frame, bg='white')
            feature_frame.pack(fill=tk.X, pady=5)

            tk.Label(feature_frame, text=icon, font=('Arial', 14),
                     bg='white', fg=self.colors['primary']).pack(side=tk.LEFT, padx=5)
            tk.Label(feature_frame, text=text, font=('Segoe UI', 11),
                     bg='white', fg=self.colors['text']).pack(side=tk.LEFT, padx=5)

        # Правая панель - форма регистрации
        right_panel = tk.Frame(content, bg='white', relief='solid', bd=1)
        right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)

        form_frame = tk.Frame(right_panel, bg='white', padx=40, pady=40)
        form_frame.pack(fill=tk.BOTH, expand=True)

        tk.Label(form_frame, text="Регистрация участника",
                 font=('Segoe UI', 18, 'bold'),
                 bg='white', fg=self.colors['text']).pack(pady=(0, 30))

        # Поля формы (убрали номер зачетки)
        fields = [
            ("ФИО", "user_name", ""),
            ("Группа", "user_group", ""),
        ]

        self.entries = {}
        for label_text, var_name, placeholder in fields:
            field_frame = tk.Frame(form_frame, bg='white')
            field_frame.pack(fill=tk.X, pady=12)

            tk.Label(field_frame, text=label_text,
                     font=('Segoe UI', 11),
                     bg='white', fg=self.colors['text']).pack(anchor='w')

            entry = tk.Entry(field_frame,
                             font=('Segoe UI', 12),
                             relief='solid',
                             bd=1,
                             highlightthickness=1,
                             highlightcolor=self.colors['primary'])
            entry.pack(fill=tk.X, pady=5, ipady=8)
            entry.insert(0, placeholder)

            self.entries[var_name] = entry

        # Выбор режима
        mode_frame = tk.Frame(form_frame, bg='white')
        mode_frame.pack(fill=tk.X, pady=15)

        tk.Label(mode_frame, text="Режим тестирования:",
                 font=('Segoe UI', 11),
                 bg='white', fg=self.colors['text']).pack(anchor='w')

        self.mode_var = tk.StringVar(value="экзамен")

        mode_radio_frame = tk.Frame(mode_frame, bg='white')
        mode_radio_frame.pack(fill=tk.X, pady=5)

        tk.Radiobutton(mode_radio_frame, text="Тренировка",
                       variable=self.mode_var, value="тренировка",
                       font=('Segoe UI', 10),
                       bg='white', fg=self.colors['text'],
                       selectcolor=self.colors['selected']).pack(anchor='w', pady=2)

        tk.Radiobutton(mode_radio_frame, text="Экзамен",
                       variable=self.mode_var, value="экзамен",
                       font=('Segoe UI', 10),
                       bg='white', fg=self.colors['text'],
                       selectcolor=self.colors['selected']).pack(anchor='w', pady=2)

        # Кнопка начала
        start_btn = ttk.Button(form_frame, text="НАЧАТЬ ТЕСТИРОВАНИЕ",
                               style='Primary.TButton',
                               command=self.validate_and_start)
        start_btn.pack(pady=30, ipadx=30)

        # Нижняя панель
        footer = tk.Frame(main_container, bg='white', height=50)
        footer.pack(side=tk.BOTTOM, fill=tk.X)

        tk.Label(footer, text="© 2026 Кафедра Электроники и теории электросвязи. Все права защищены.",
                 font=('Segoe UI', 9),
                 bg='white', fg=self.colors['text_light']).pack(pady=15)

        tk.Label(footer, text=f"Версия 2.1.0 ",
                 font=('Segoe UI', 9),
                 bg='white', fg=self.colors['text_light']).pack()

    def validate_and_start(self):
        """Проверяет данные и начинает тест"""
        self.user_name = self.entries['user_name'].get().strip()
        self.user_group = self.entries['user_group'].get().strip()
        self.test_mode = self.mode_var.get()

        if not self.user_name:
            messagebox.showwarning("Внимание", "Пожалуйста, введите ваше ФИО")
            return

        # Выбор вопросов в зависимости от режима
        if self.test_mode == "тренировка":
            # В тренировке используем ВСЕ вопросы
            self.selected_questions = self.all_questions.copy()
            self.time_limit = 0  # Без ограничения времени
        else:
            # В экзамене - 20 случайных вопросов
            if len(self.all_questions) < 20:
                messagebox.showerror("Ошибка",
                                     f"Недостаточно вопросов в базе для экзамена!\nНужно 20, а есть {len(self.all_questions)}")
                return
            self.selected_questions = random.sample(self.all_questions, 20)
            self.time_limit = 600  # 5 минут

        self.start_test()

    def start_test(self):
        """Начинает тест"""
        self.current_question_index = 0
        self.score = 0
        self.user_answers = [[] for _ in range(len(self.selected_questions))]
        self.answer_vars = {}
        self.questions_answered = 0
        self.correct_answers = 0
        self.time_spent = []

        # Очищаем окно и создаем интерфейс теста
        self.clear_window()
        self.create_test_interface()

        # Запускаем таймер если в режиме экзамена
        if self.test_mode == "экзамен":
            self.start_time = time.time()
            self.timer_running = True
            self.update_timer()

        # Показываем первый вопрос
        self.show_question(0)

    def create_test_interface(self):
        """Создает интерфейс для прохождения теста"""
        # Главный контейнер
        main_container = tk.Frame(self.root, bg=self.colors['bg'])
        main_container.pack(fill=tk.BOTH, expand=True)

        # Верхняя панель
        self.create_top_panel(main_container)

        # Основная область
        center_container = tk.Frame(main_container, bg=self.colors['bg'])
        center_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        # Левая боковая панель
        self.create_sidebar(center_container)

        # Основная область с вопросом и ответами
        self.create_main_content(center_container)

        # Нижняя панель
        self.create_bottom_panel(main_container)

    def create_top_panel(self, parent):
        """Создает верхнюю информационную панель"""
        top_frame = tk.Frame(parent, bg=self.colors['header_bg'], height=70)
        top_frame.pack(fill=tk.X)
        top_frame.pack_propagate(False)

        # Информация о пользователе
        user_info = tk.Frame(top_frame, bg=self.colors['header_bg'])
        user_info.pack(side=tk.LEFT, padx=30, pady=10)

        tk.Label(user_info,
                 text=f"{self.user_name} | {self.user_group}",
                 font=('Segoe UI', 12, 'bold'),
                 bg=self.colors['header_bg'], fg='white').pack(anchor='w')

        tk.Label(user_info,
                 text=f"Режим: {self.test_mode.capitalize()} | Вопросов: {len(self.selected_questions)}",
                 font=('Segoe UI', 10),
                 bg=self.colors['header_bg'], fg='#bbdefb').pack(anchor='w')

        # Таймер и счетчик
        timer_info = tk.Frame(top_frame, bg=self.colors['header_bg'])
        timer_info.pack(side=tk.RIGHT, padx=30, pady=10)

        if self.test_mode == "экзамен":
            tk.Label(timer_info, text="Осталось времени:",
                     font=('Segoe UI', 10),
                     bg=self.colors['header_bg'], fg='white').pack(anchor='e')

            self.timer_display = tk.Label(timer_info,
                                          text="10:00",
                                          font=('Segoe UI', 20, 'bold'),
                                          bg=self.colors['timer_ok'],
                                          fg='white',
                                          width=6,
                                          relief='solid',
                                          bd=1)
            self.timer_display.pack(anchor='e')
        else:
            tk.Label(timer_info, text="Тренировочный режим",
                     font=('Segoe UI', 10, 'italic'),
                     bg=self.colors['header_bg'], fg='#bbdefb').pack(anchor='e')

    def create_sidebar(self, parent):
        """Создает боковую панель с навигацией по вопросам"""
        sidebar = tk.Frame(parent, bg=self.colors['sidebar_bg'], width=180)
        sidebar.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))
        sidebar.pack_propagate(False)

        tk.Label(sidebar, text="Вопросы",
                 font=('Segoe UI', 12, 'bold'),
                 bg=self.colors['sidebar_bg'], fg='white',
                 pady=15).pack()

        # Сетка кнопок вопросов
        self.question_buttons = []
        questions_grid = tk.Frame(sidebar, bg=self.colors['sidebar_bg'])
        questions_grid.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Рассчитываем количество строк и столбцов для сетки
        total_questions = len(self.selected_questions)
        cols = 5
        rows = (total_questions + cols - 1) // cols

        for i in range(total_questions):
            row = i // cols
            col = i % cols

            btn = tk.Button(questions_grid,
                            text=str(i + 1),
                            font=('Segoe UI', 10),
                            width=3,
                            bg=self.colors['sidebar_bg'],
                            fg='white',
                            relief='solid',
                            bd=1,
                            command=lambda idx=i: self.show_question(idx))

            btn.grid(row=row, column=col, padx=2, pady=2)
            self.question_buttons.append(btn)

        # Статистика внизу
        stats_frame = tk.Frame(sidebar, bg=self.colors['sidebar_bg'])
        stats_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=10)

        self.stats_label = tk.Label(stats_frame,
                                    text=f"Ответов: 0/{len(self.selected_questions)}",
                                    font=('Segoe UI', 10),
                                    bg=self.colors['sidebar_bg'],
                                    fg='#bbdefb')
        self.stats_label.pack()

    def create_main_content(self, parent):
        """Создает основную область с вопросом и ответами"""
        main_area = tk.Frame(parent, bg=self.colors['bg'])
        main_area.pack(fill=tk.BOTH, expand=True)

        # Карточка с вопросом
        question_card = tk.Frame(main_area, bg='white', relief='solid', bd=1)
        question_card.pack(fill=tk.BOTH, expand=True, pady=(0, 10))

        # Заголовок вопроса
        question_header = tk.Frame(question_card, bg='#f5f5f5', height=40)
        question_header.pack(fill=tk.X)
        question_header.pack_propagate(False)

        self.question_header_text = tk.Label(question_header,
                                             text=f"Вопрос 1 из {len(self.selected_questions)}",
                                             font=('Segoe UI', 11, 'bold'),
                                             bg='#f5f5f5',
                                             fg=self.colors['text'])
        self.question_header_text.pack(side=tk.LEFT, padx=15, pady=10)

        # Текст вопроса
        self.question_text = tk.Text(question_card,
                                     height=6,
                                     font=('Segoe UI', 12),
                                     bg='white',
                                     fg=self.colors['text'],
                                     wrap=tk.WORD,
                                     relief='flat',
                                     padx=20,
                                     pady=20)
        self.question_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.question_text.config(state=tk.DISABLED)

        # Карточка с ответами
        answers_card = tk.Frame(main_area, bg='white', relief='solid', bd=1)
        answers_card.pack(fill=tk.BOTH, expand=True)

        # Заголовок ответов
        answers_header = tk.Frame(answers_card, bg='#f5f5f5', height=40)
        answers_header.pack(fill=tk.X)
        answers_header.pack_propagate(False)

        tk.Label(answers_header,
                 text="Выберите правильные ответы (может быть несколько):",
                 font=('Segoe UI', 11),
                 bg='#f5f5f5',
                 fg=self.colors['text']).pack(side=tk.LEFT, padx=15, pady=10)

        # Область с чекбоксами
        self.canvas = tk.Canvas(answers_card, bg='white', highlightthickness=0)
        scrollbar = ttk.Scrollbar(answers_card, orient="vertical", command=self.canvas.yview)

        self.scrollable_frame = tk.Frame(self.canvas, bg='white')
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )

        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=scrollbar.set)

        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(10, 0), pady=10)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y, pady=10)

    def create_bottom_panel(self, parent):
        """Создает нижнюю панель управления"""
        bottom_frame = tk.Frame(parent, bg='white', height=80)
        bottom_frame.pack(side=tk.BOTTOM, fill=tk.X)
        bottom_frame.pack_propagate(False)

        # Левая часть - управление
        control_frame = tk.Frame(bottom_frame, bg='white')
        control_frame.pack(side=tk.LEFT, padx=30, pady=15)

        # Кнопка "Назад"
        self.prev_btn = ttk.Button(control_frame, text="◀ Назад",
                                   style='Secondary.TButton',
                                   command=self.prev_question)
        self.prev_btn.pack(side=tk.LEFT, padx=2)

        # Кнопка "Сохранить ответ"
        ttk.Button(control_frame, text="💾 Сохранить",
                   style='Secondary.TButton',
                   command=self.save_current_answer).pack(side=tk.LEFT, padx=2)

        # Кнопка "Очистить"
        ttk.Button(control_frame, text="🗑 Очистить",
                   style='Secondary.TButton',
                   command=self.clear_current_answers).pack(side=tk.LEFT, padx=2)

        # Кнопка "Далее"
        self.next_btn = ttk.Button(control_frame, text="Далее ▶",
                                   style='Primary.TButton',
                                   command=self.next_question)
        self.next_btn.pack(side=tk.LEFT, padx=2)

        # Правая часть - завершение
        finish_frame = tk.Frame(bottom_frame, bg='white')
        finish_frame.pack(side=tk.RIGHT, padx=30, pady=15)

        # Кнопка завершения
        ttk.Button(finish_frame, text="🏁 Завершить тест",
                   style='Success.TButton',
                   command=self.confirm_finish).pack(side=tk.RIGHT, padx=2)

        # Прогресс-бар
        progress_frame = tk.Frame(bottom_frame, bg='white')
        progress_frame.place(relx=0.5, rely=0.5, anchor='center')

        self.progress_bar = ttk.Progressbar(progress_frame,
                                            length=300,
                                            mode='determinate',
                                            style='Custom.Horizontal.TProgressbar')
        self.progress_bar.pack()

        self.progress_label = tk.Label(progress_frame,
                                       text="0%",
                                       font=('Segoe UI', 10),
                                       bg='white',
                                       fg=self.colors['text'])
        self.progress_label.pack()

    def show_question(self, index):
        """Показывает вопрос по указанному индексу"""
        if index < 0 or index >= len(self.selected_questions):
            return

        # Сохраняем время, затраченное на предыдущий вопрос
        if hasattr(self, 'question_start_time'):
            time_spent = time.time() - self.question_start_time
            self.time_spent.append(time_spent)

        self.current_question_index = index
        question = self.selected_questions[index]
        self.question_start_time = time.time()

        # Обновляем заголовок
        self.question_header_text.config(text=f"Вопрос {index + 1} из {len(self.selected_questions)}")

        # Обновляем текст вопроса
        self.question_text.config(state=tk.NORMAL)
        self.question_text.delete(1.0, tk.END)

        # Добавляем информацию о сложности и категории
        category_info = f"[{question.get('category', 'Общая')}] "
        difficulty_info = f"Сложность: {question.get('difficulty', 'средняя')}\n\n"

        self.question_text.insert(1.0, category_info + difficulty_info + question['question'])
        self.question_text.config(state=tk.DISABLED)

        # Очищаем предыдущие варианты ответов
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()

        # Создаем чекбоксы для вариантов ответов
        self.answer_vars = {}

        # Создаем основной контейнер для ответов с выравниванием
        answers_container = tk.Frame(self.scrollable_frame, bg='white')
        answers_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        for letter, text in question['options'].items():
            var = tk.BooleanVar()
            self.answer_vars[letter] = var

            # Восстанавливаем сохраненный ответ
            if index < len(self.user_answers):
                saved_answer = self.user_answers[index]
                var.set(letter in saved_answer)

            # Создаем фрейм для каждого варианта ответа
            option_frame = tk.Frame(answers_container, bg='white')
            option_frame.pack(fill=tk.X, pady=8, anchor='w')

            # Чекбокс с фиксированной шириной
            cb = tk.Checkbutton(option_frame,
                                variable=var,
                                bg='white',
                                font=('Segoe UI', 11),
                                cursor='hand2')
            cb.pack(side=tk.LEFT, padx=(0, 15))

            # Метка с текстом ответа - начинается с одного уровня
            label = tk.Label(option_frame,
                            text=f"{letter}. {text}",
                            font=('Segoe UI', 11),
                            bg='white',
                            fg=self.colors['text'],
                            wraplength=850,
                            justify=tk.LEFT,
                            anchor='w')
            label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            # Убедимся, что все варианты начинаются с одной горизонтальной позиции
            option_frame.grid_columnconfigure(1, weight=1)

        # Обновляем кнопки навигации
        self.prev_btn.config(state='normal' if index > 0 else 'disabled')

        if index == len(self.selected_questions) - 1:
            self.next_btn.config(text="Последний вопрос")
        else:
            self.next_btn.config(text="Далее ▶")

        # Обновляем кнопку вопроса
        for i, btn in enumerate(self.question_buttons):
            if i == index:
                btn.config(bg=self.colors['primary'], fg='white')
            elif self.user_answers[i]:
                btn.config(bg=self.colors['success_light'], fg='white')
            else:
                btn.config(bg=self.colors['sidebar_bg'], fg='white')

        # Обновляем прогресс
        progress = ((index + 1) / len(self.selected_questions)) * 100
        self.progress_bar['value'] = progress
        self.progress_label.config(text=f"{int(progress)}%")

        # Обновляем статистику
        answered = len([a for a in self.user_answers if a])
        self.stats_label.config(text=f"Ответов: {answered}/{len(self.selected_questions)}")

    def save_current_answer(self):
        """Сохраняет текущий ответ"""
        selected = [letter for letter, var in self.answer_vars.items() if var.get()]
        self.user_answers[self.current_question_index] = selected

        # Обновляем кнопку вопроса
        if self.current_question_index < len(self.question_buttons):
            btn = self.question_buttons[self.current_question_index]
            if selected:
                btn.config(bg=self.colors['success_light'], fg='white')
            else:
                btn.config(bg=self.colors['sidebar_bg'], fg='white')

        # Обновляем статистику
        answered = len([a for a in self.user_answers if a])
        self.stats_label.config(text=f"Ответов: {answered}/{len(self.selected_questions)}")

        # Показываем сообщение только если есть сохраненные ответы
        if selected:
            messagebox.showinfo("Сохранено", "Ответ сохранен!")

    def clear_current_answers(self):
        """Очищает текущие ответы"""
        for var in self.answer_vars.values():
            var.set(False)
        self.user_answers[self.current_question_index] = []

        # Обновляем кнопку вопроса
        if self.current_question_index < len(self.question_buttons):
            btn = self.question_buttons[self.current_question_index]
            btn.config(bg=self.colors['sidebar_bg'], fg='white')

    def next_question(self):
        """Переходит к следующему вопросу"""
        self.save_current_answer()

        if self.current_question_index < len(self.selected_questions) - 1:
            self.show_question(self.current_question_index + 1)
        else:
            self.confirm_finish()

    def prev_question(self):
        """Переходит к предыдущему вопросу"""
        self.save_current_answer()

        if self.current_question_index > 0:
            self.show_question(self.current_question_index - 1)

    def update_timer(self):
        """Обновляет таймер"""
        if not self.timer_running:
            return

        elapsed = time.time() - self.start_time
        remaining = max(0, self.time_limit - elapsed)

        # Форматируем время
        minutes = int(remaining // 60)
        seconds = int(remaining % 60)
        time_str = f"{minutes:02d}:{seconds:02d}"

        self.timer_display.config(text=time_str)

        # Меняем цвет в зависимости от оставшегося времени
        if remaining < 60:
            self.timer_display.config(bg=self.colors['timer_critical'])
        elif remaining < 120:
            self.timer_display.config(bg=self.colors['timer_warning'])
        else:
            self.timer_display.config(bg=self.colors['timer_ok'])

        # Проверяем, не истекло ли время
        if remaining <= 0:
            self.timer_running = False
            messagebox.showwarning("Время вышло!",
                                   "Время на выполнение теста истекло!\nТест будет завершен.")
            self.finish_test()
        else:
            self.root.after(1000, self.update_timer)

    def confirm_finish(self):
        """Подтверждение завершения теста"""
        answered = len([a for a in self.user_answers if a])
        total = len(self.selected_questions)

        if answered < total:
            if not messagebox.askyesno("Завершение теста",
                                       f"Вы ответили только на {answered} из {total} вопросов.\n"
                                       "Вы уверены, что хотите завершить тест?\n\n"
                                       "Все сохраненные ответы будут учтены."):
                return

        self.finish_test()

    def calculate_results(self):
        """Рассчитывает результаты теста"""
        total_score = 0
        max_score = 0
        correct_count = 0
        detailed_results = []

        for i, question in enumerate(self.selected_questions):
            max_score += question['points']
            user_answer = set(self.user_answers[i])
            correct_answer = set(question['correct'])

            # Проверяем правильность ответа
            is_correct = user_answer == correct_answer
            if is_correct:
                correct_count += 1

            # Рассчитываем баллы
            if not user_answer:
                question_score = 0
            elif is_correct:
                # Полностью правильно - полный балл
                question_score = question['points']
            else:
                # Частично правильно - пропорциональный балл
                correct_selected = len(user_answer.intersection(correct_answer))
                incorrect_selected = len(user_answer - correct_answer)
                total_correct = len(correct_answer)

                if correct_selected > incorrect_selected:
                    question_score = max(1, int(
                        (correct_selected - incorrect_selected) / total_correct * question['points']
                    ))
                else:
                    question_score = 0

            total_score += question_score

            detailed_results.append({
                'number': i + 1,
                'question': question['question'],
                'user_answer': list(user_answer),
                'correct_answer': list(correct_answer),
                'score': question_score,
                'max_score': question['points'],
                'is_correct': is_correct,
                'category': question.get('category', 'Общая'),
                'difficulty': question.get('difficulty', 'средняя'),
                'explanation': question.get('explanation', '')
            })

        # Рассчитываем проценты
        percentage = (total_score / max_score * 100) if max_score > 0 else 0
        accuracy = (correct_count / len(self.selected_questions) * 100) if self.selected_questions else 0

        # Определяем оценку по 5-балльной шкале
        if percentage >= 0:
            grade = 5
            grade_text = "Отлично"
        elif percentage >= 65:
            grade = 4
            grade_text = "Хорошо"
        elif percentage >= 60:
            grade = 3
            grade_text = "Удовлетворительно"
        else:
            grade = 2
            grade_text = "Неудовлетворительно"

        return {
            'total_score': total_score,
            'max_score': max_score,
            'percentage': percentage,
            'correct_count': correct_count,
            'total_questions': len(self.selected_questions),
            'accuracy': accuracy,
            'grade': grade,
            'grade_text': grade_text,
            'details': detailed_results
        }

    def finish_test(self):
        """Завершает тест и показывает результаты"""
        self.timer_running = False
        self.save_current_answer()

        # Рассчитываем результаты
        results = self.calculate_results()

        # Общее время выполнения
        if self.test_mode == "экзамен" and self.start_time:
            total_time = min(time.time() - self.start_time, self.time_limit)
        else:
            total_time = sum(self.time_spent) if self.time_spent else 0

        # Показываем результаты
        self.show_results_screen(results, total_time)

    def show_results_screen(self, results, total_time):
        """Показывает экран с результатами"""
        self.clear_window()

        # Основной контейнер
        main_container = tk.Frame(self.root, bg=self.colors['bg'])
        main_container.pack(fill=tk.BOTH, expand=True)

        # Верхняя панель
        header = tk.Frame(main_container, bg=self.colors['header_bg'], height=70)
        header.pack(fill=tk.X)

        tk.Label(header, text="Результаты тестирования",
                 font=('Segoe UI', 22, 'bold'),
                 bg=self.colors['header_bg'], fg='white').pack(expand=True, pady=20)

        # Основное содержимое
        content = tk.Frame(main_container, bg=self.colors['bg'], padx=40, pady=30)
        content.pack(fill=tk.BOTH, expand=True)

        # Основная информация о результатах
        main_results_frame = tk.Frame(content, bg='white', relief='solid', bd=1)
        main_results_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 20))

        inner_frame = tk.Frame(main_results_frame, bg='white', padx=40, pady=40)
        inner_frame.pack(fill=tk.BOTH, expand=True)

        # Оценка
        grade_color = self.colors['success'] if results['grade'] >= 3 else self.colors['danger']

        tk.Label(inner_frame, text=f"ОЦЕНКА: {results['grade']} ({results['grade_text']})",
                 font=('Segoe UI', 24, 'bold'),
                 bg='white', fg=grade_color).pack(pady=(0, 30))

        # Основные метрики в виде карточек
        metrics_frame = tk.Frame(inner_frame, bg='white')
        metrics_frame.pack(fill=tk.X, pady=(0, 30))

        metrics = [
            ("Набрано баллов", f"{results['total_score']}/{results['max_score']}",
             f"{results['percentage']:.1f}%", self.colors['primary']),
            ("Правильных ответов", f"{results['correct_count']}/{results['total_questions']}",
             f"{results['accuracy']:.1f}%", self.colors['success']),
            ("Время выполнения", f"{total_time:.1f} сек",
             "Экзамен" if self.test_mode == "экзамен" else "Тренировка",
             self.colors['warning']),
        ]

        for i, (title, value, subvalue, color) in enumerate(metrics):
            metric_card = tk.Frame(metrics_frame, bg=color, relief='solid', bd=1)
            metric_card.grid(row=0, column=i, padx=10, sticky='nsew')

            tk.Label(metric_card, text=title,
                     font=('Segoe UI', 11),
                     bg=color, fg='white').pack(pady=(15, 5))

            tk.Label(metric_card, text=value,
                     font=('Segoe UI', 18, 'bold'),
                     bg=color, fg='white').pack(pady=5)

            tk.Label(metric_card, text=subvalue,
                     font=('Segoe UI', 10),
                     bg=color, fg='#e3f2fd').pack(pady=(5, 15))

        # Распределение весов столбцов
        for i in range(3):
            metrics_frame.grid_columnconfigure(i, weight=1)

        # Детали по категориям
        categories = {}
        for detail in results['details']:
            cat = detail['category']
            if cat not in categories:
                categories[cat] = {'correct': 0, 'total': 0, 'score': 0, 'max_score': 0}
            categories[cat]['total'] += 1
            categories[cat]['score'] += detail['score']
            categories[cat]['max_score'] += detail['max_score']
            if detail['is_correct']:
                categories[cat]['correct'] += 1

        # Таблица категорий (показываем только если есть категории)
        if categories:
            tk.Label(inner_frame, text="Результаты по категориям:",
                     font=('Segoe UI', 14, 'bold'),
                     bg='white', fg=self.colors['text']).pack(anchor='w', pady=(0, 10))

            # Создаем таблицу
            table_frame = tk.Frame(inner_frame, bg='white')
            table_frame.pack(fill=tk.X, pady=(0, 20))

            # Заголовки таблицы
            headers = ["Категория", "Вопросы", "Правильно", "Баллы", "Процент"]
            for col, header in enumerate(headers):
                tk.Label(table_frame, text=header,
                         font=('Segoe UI', 10, 'bold'),
                         bg='#f5f5f5', fg=self.colors['text'],
                         relief='solid', bd=1, padx=10, pady=5).grid(row=0, column=col, sticky='nsew')

            # Данные таблицы
            for row, (cat, data) in enumerate(categories.items(), 1):
                percentage = (data['score'] / data['max_score'] * 100) if data['max_score'] > 0 else 0

                tk.Label(table_frame, text=cat,
                         font=('Segoe UI', 10),
                         bg='white', fg=self.colors['text'],
                         relief='solid', bd=1, padx=10, pady=5).grid(row=row, column=0, sticky='nsew')

                tk.Label(table_frame, text=str(data['total']),
                         font=('Segoe UI', 10),
                         bg='white', fg=self.colors['text'],
                         relief='solid', bd=1, padx=10, pady=5).grid(row=row, column=1, sticky='nsew')

                tk.Label(table_frame, text=f"{data['correct']}/{data['total']}",
                         font=('Segoe UI', 10),
                         bg='white', fg=self.colors['text'],
                         relief='solid', bd=1, padx=10, pady=5).grid(row=row, column=2, sticky='nsew')

                tk.Label(table_frame, text=f"{data['score']}/{data['max_score']}",
                         font=('Segoe UI', 10),
                         bg='white', fg=self.colors['text'],
                         relief='solid', bd=1, padx=10, pady=5).grid(row=row, column=3, sticky='nsew')

                color = self.colors['success'] if percentage >= 60 else self.colors['danger']
                tk.Label(table_frame, text=f"{percentage:.1f}%",
                         font=('Segoe UI', 10),
                         bg='white', fg=color,
                         relief='solid', bd=1, padx=10, pady=5).grid(row=row, column=4, sticky='nsew')

            # Настраиваем веса столбцов
            for col in range(5):
                table_frame.grid_columnconfigure(col, weight=1)

        # Панель кнопок
        buttons_frame = tk.Frame(content, bg=self.colors['bg'])
        buttons_frame.pack(fill=tk.X, pady=10)

        # Кнопка "Подробные результаты"
        ttk.Button(buttons_frame, text="📊 Детальные результаты",
                   style='Primary.TButton',
                   command=lambda: self.show_detailed_results(results['details'])).pack(side=tk.LEFT, padx=5)

        # Кнопка "Анализ ошибок"
        ttk.Button(buttons_frame, text="🔍 Анализ ошибок",
                   style='Secondary.TButton',
                   command=lambda: self.show_error_analysis(results['details'])).pack(side=tk.LEFT, padx=5)

        # Кнопка "Новый тест"
        ttk.Button(buttons_frame, text="🔄 Новый тест",
                   style='Secondary.TButton',
                   command=self.show_start_screen).pack(side=tk.RIGHT, padx=5)

        # Кнопка "Выход"
        ttk.Button(buttons_frame, text="🚪 Выход",
                   style='Danger.TButton',
                   command=self.root.quit).pack(side=tk.RIGHT, padx=5)

        # Статистика внизу
        footer = tk.Frame(main_container, bg='white', height=50)
        footer.pack(side=tk.BOTTOM, fill=tk.X)

        date_str = datetime.now().strftime("%d.%m.%Y %H:%M")
        tk.Label(footer, text=f"Тестирование завершено: {date_str} | "
                              f"Режим: {self.test_mode} | "
                              f"Вопросов: {len(self.selected_questions)}",
                 font=('Segoe UI', 9),
                 bg='white', fg=self.colors['text_light']).pack(pady=15)

    def show_detailed_results(self, details):
        """Показывает детальные результаты по всем вопросам"""
        details_window = tk.Toplevel(self.root)
        details_window.title("Детальные результаты")
        details_window.geometry("1000x700")
        details_window.configure(bg=self.colors['bg'])

        self.center_window_on_parent(details_window)

        # Заголовок
        header = tk.Frame(details_window, bg=self.colors['header_bg'], height=60)
        header.pack(fill=tk.X)

        tk.Label(header, text="Детализация результатов",
                 font=('Segoe UI', 16, 'bold'),
                 bg=self.colors['header_bg'], fg='white').pack(expand=True, pady=15)

        # Область с текстом
        text_frame = tk.Frame(details_window, bg='white')
        text_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        text_widget = tk.Text(text_frame,
                              font=('Segoe UI', 10),
                              bg='white',
                              fg=self.colors['text'],
                              wrap=tk.WORD)
        text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(text_frame, command=text_widget.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        text_widget.config(yscrollcommand=scrollbar.set)

        # Добавляем детали
        for detail in details:
            text_widget.insert(tk.END, "\n" + "=" * 100 + "\n")
            text_widget.insert(tk.END, f"Вопрос {detail['number']} [{detail['category']} | {detail['difficulty']}]\n\n")
            text_widget.insert(tk.END, f"{detail['question']}\n\n")

            # Ответы
            user_ans = ', '.join(detail['user_answer']) if detail['user_answer'] else 'нет ответа'
            correct_ans = ', '.join(detail['correct_answer'])

            text_widget.insert(tk.END, f"Ваш ответ: {user_ans}\n")
            text_widget.insert(tk.END, f"Правильный ответ: {correct_ans}\n\n")

            # Результат
            status = "✅ ПРАВИЛЬНО" if detail['is_correct'] else "❌ НЕПРАВИЛЬНО"
            text_widget.insert(tk.END, f"Результат: {status} | Баллы: {detail['score']}/{detail['max_score']}\n\n")

            # Объяснение
            if detail['explanation']:
                text_widget.insert(tk.END, f"Объяснение: {detail['explanation']}\n")

        text_widget.config(state=tk.DISABLED)

    def show_error_analysis(self, details):
        """Показывает анализ ошибок"""
        errors = [d for d in details if not d['is_correct']]

        if not errors:
            messagebox.showinfo("Анализ ошибок", "У вас нет ошибок! Отличный результат!")
            return

        analysis_window = tk.Toplevel(self.root)
        analysis_window.title("Анализ ошибок")
        analysis_window.geometry("900x600")
        analysis_window.configure(bg=self.colors['bg'])

        self.center_window_on_parent(analysis_window)

        # Заголовок
        header = tk.Frame(analysis_window, bg=self.colors['header_bg'], height=60)
        header.pack(fill=tk.X)

        tk.Label(header, text=f"Анализ ошибок ({len(errors)} вопросов)",
                 font=('Segoe UI', 16, 'bold'),
                 bg=self.colors['header_bg'], fg='white').pack(expand=True, pady=15)

        # Область с текстом
        text_frame = tk.Frame(analysis_window, bg='white')
        text_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        text_widget = tk.Text(text_frame,
                              font=('Segoe UI', 10),
                              bg='white',
                              fg=self.colors['text'],
                              wrap=tk.WORD)
        text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(text_frame, command=text_widget.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        text_widget.config(yscrollcommand=scrollbar.set)

        # Добавляем анализ ошибок
        for error in errors:
            text_widget.insert(tk.END, f"\n❌ Вопрос {error['number']}: {error['category']}\n\n")
            text_widget.insert(tk.END, f"{error['question']}\n\n")

            text_widget.insert(tk.END,
                               f"Ваш ответ: {', '.join(error['user_answer']) if error['user_answer'] else 'нет ответа'}\n")
            text_widget.insert(tk.END, f"Правильный ответ: {', '.join(error['correct_answer'])}\n\n")

            if error['explanation']:
                text_widget.insert(tk.END, f"📚 {error['explanation']}\n")

            text_widget.insert(tk.END, "-" * 80 + "\n")

        text_widget.config(state=tk.DISABLED)

    def center_window_on_parent(self, window):
        """Центрирует дочерное окно относительно родительского"""
        window.update_idletasks()
        width = window.winfo_width()
        height = window.winfo_height()
        x = self.root.winfo_x() + (self.root.winfo_width() // 2) - (width // 2)
        y = self.root.winfo_y() + (self.root.winfo_height() // 2) - (height // 2)
        window.geometry(f'{width}x{height}+{x}+{y}')

    def clear_window(self):
        """Очищает все виджеты в окне"""
        for widget in self.root.winfo_children():
            widget.destroy()


def main():
    """Главная функция"""
    root = tk.Tk()
    app = TestApp(root)
    root.mainloop()


if __name__ == "__main__":
    main()